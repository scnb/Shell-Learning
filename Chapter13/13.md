子Shell与进程处理
=================

在脚本被执行的时候，当前的Shell会启动另一个Shell实例，每个Shell脚本都有效的运行在父Shell的一个子进程中。

## 1.子Shell

Shell本身是一个程序，也可以启动自己的子进程，这些子进程称为子Shell。

### 1.什么是子Shell

当用户登录Linux或者UNIX之后，操作系统会根据用户/etc/passwd文件中的配置启动一个Shell进程，该Shell进程为当前用户所执行的Shell命令的父进程。

用户在执行一个Shell脚本的时候，父Shell会根据脚本程序的第一行#! 符号后面指定的解释器程序开启一个子Shell进程，然后在子Shell的环境中执行该Shell脚本。

当子Shell中的脚本执行完毕，该子进程Shell结束，并且返回到父Shell中。

### 2.内部命令、保留字和外部命令

Shell命令分为内部命令和外部命令。

**内部命令**：是指包含在Shell工具包中的命令，内部命令是Shell本身的重要组成部分。

内部命令嵌在Shell程序中，并不单独以**磁盘文件**的形式存在于磁盘上。

当用户执行内部命令时，Shell并不需要创建子Shell，而是由当前的Shell程序直接解释并执行。

**保留字**：保留字不是Shell命令，而是bash Shell的内置关键字，如if、else、then、for等。

**外部命令**：外部命令是Linux系统中的使用程序部分，这些使用程序以**磁盘文件**的形式存在于磁盘中。

外部命令通常位于/usr/bin或/usr/sbin等目录中。

外部命令是由当前的Shell程序创建一个子Shell，然后在子Shell环境中执行。


### 3.在子Shell中执行命令

在bash shell中，以下几种情况通常会使Shell在子Shell中执行命令。

#### 1.圆括号结构

当一组命令放在圆括号中时，该组命令会在一个子Shell环境中执行，语法如下：

	(command1;command2;command3;…）

command1、command2、command3都是Shell命令，这些命令写在一行中。

如果每一行只有一条命令，则可以省略分号，变成如下形式：

	(
	 command1
	 command2
	 ……
	)
	
子Shell中可以访问父Shell中的变量，而在子Shell中定义的变量不能在父Shell中访问。


**Note**：通过循环结构，用户可以将Shell程序中的某一段代码放在后台执行，其方法是在圆括号结构的后面使用&操作符。

	(
	 command1
	 command2
	 ……
	) &
	

#### 2.后台执行或异步执行

在某些情况下，Shell命令需要很长的时间来执行，这时，用户可以将命令置于后台执行，而不必等待命令执行结束。

将命令置于后台的语法为：
	
	command&

后台命令和当前命令是**并行**的，相互之间没有依赖及等待关系。

所以，后台命令和当前Shell是异步的并行。

#### 3.命令替换

语法如下：

	'command'
	或者
	$(command)

command会在一个子Shell中执行，不会影响当前的Shell环境。

### 4.把子Shell中的变量值传回父Shell

在父Shell中，用户无法直接获得子Shell中变量的值。但是用户可以通过一些变通的技巧来获得子Shell中的变量的值。

#### 1.通过临时文件

在Linux中，通过临时文件传递数据是一个非常重要的技巧。

通过临时文件，用户可以在进程间传递大量的数据，不受内存空间的限制。

#### 2.使用命名管道

命名管道是Linux及UNIX系统中最古老的进程间通信的方式，同时也是一个相对简单的通信机制。


#### 3.不使用子Shell

子所以出现变量传递问题，是因为使用了子Shell。所以一个解决办法就是不使用子Shell。

用户可以通过原点命令(.)和source命令来执行脚本，使得被调用的脚本在当前shell中执行。

通过原点命令，使得两个脚本在同一个Shell进程中执行，变量可以共享。


## 2.进程处理

### 1.什么是进程

**进程**是指在自身的**虚拟地址空间**运行的一个单独的程序，是程序执行的**基本单元**。

进程与程序是有区别的，进程由程序产生。

程序只是一个静态的指令集合，不占系统的运行资源；而进程是一个动态的、使用系统运行资源的程序。

大致来说，Linux中的进程可以分为一下3类：

1. 交互进程：由Shell启动的进程，即可在前台运行，又可在后台运行。
2. 批处理进程：又称为序列。
3. 监控进程：又称为守护进程，Linux的服务进程，在后台运行。


### 2.通过脚本监控进程

该小节讲了一个通过脚本来监控web服务器进程是否存在，如果不存在，则启动该进程。

由。于本机上没有Apache服务器，所以不能成功运行该脚本。


### 3.作业控制

**作业**：通常情况下，我们把一个正在执行的进程称为一个作业。

但是，进程和作业是有区别的。

一般来说，进程是针对**操作系统**而言的，是操作系统中程序执行的基本单位。

作业是针对**用户**而言的，是用户为了完成某项任务而启动的进程，一个作业可以包含一个或多个进程。

例如，下面的一组命令构成了一个作业：

	man ls | grep long | more

虽然是一个作业，但是Shell启动了三个进程：ls、grep和more。

**作业控制**：用户控制 正在执行的 组成作业的进程的 行为。


进程挂起的方法有：通过sleep函数使进程休眠，语法如下：

	sleep number[suffix]

其中，number是休眠的时间长度，suffix是时间单位，默认是秒。通过用字母s、m、h、d等可以表示秒、分钟、小时、天等。

当用户处理完前台的进程后，可以使用fg命令将后台的作业移至前台执行，语法如下：

	fg [jobspec]

参数jobspec用来指定要切换的作业，可以是作业号或者是作业的命令名称等。

fg中指定命令作业的方法有：

|方法|说明|
|----|----|
|%n|n为整数，表示作业号|
|%string|以字符串string开头的命令代表的作业|
|%?string|包含字符串string的命令代表的作业|
|%+或者%%|最近提交的一个作业|
|%-|倒数第二个提交的作业|


Shell提供了另一个内部命令jobs来查看正在后台执行的作业列表，语法如下：

	jobs [options]

options表示jobs命令的选项，常用的选项有-l和-p，前者表示作业的详细信息，后者表示只显示作业的进程ID。


作业的状态有：

|状态|说明|
|----|----|
|Running|该作业没有被挂起，而是正在运行|
|Done|该作业已经完成并返回退出状态码0|
|Done(code)|该作业已经完成并退出，但是状态码不是0|
|Stopped|该作业被挂起|


用户可以使用disown命令删除作业列表中的作业，基本语法如下：

	disown [jobspec...]

jobspec可以是作业的ID、也可以是作业的命令。


### 4.信号与trap命令

**信号**在Linux系统中是非常重要的一种通信机制。

信号在软件层次上是对**硬件中断**的一种模拟，因此，信号即软件中断。

在Linux系统中，用户可以通过kill命令给某个进程发送一个特定信号，也可以通过键盘发送信号。

常用信号及其含义：

|信号|值|涵义|
|----|--|----|
|SIGHUP|1|终端挂起或者控制进程终止|
|SIGINT|2|键盘中断|
|SIGQUIT|3|键盘的退出键被按下|
|SIGABRT|6|由abort(3)发出的退出指令|
|SIGKILL|9|立即结束进程|

最常用的信号是SIGKILL，该信号用来立即结束进程的运行。并且SIGKILL信号不能被阻塞、处理和忽略。

kill的基本语法为：

	kill [-s signal|-p] [--] pid…

* -s选项用来指定要发送的信号
* -p选项表示只是打印指定名称的进程的ID，不发送信号
* 参数pid表示某个进程的ID

比如，杀死某个进程：
	
	kill -s 9 PID

则，该进程被杀死。

对于有些信号，进程会有默认的响应动作；而有些信号，进程可能直接会忽略；用户还可以对某些信号指定特定的响应动作。

在Shell程序中，用户可以通过trap命令来设定响应某个信号的动作，其基本语法如下：
	
	trap [[arg] sigspec……]

arg表示信号响应操作的函数，sigspec表示特定的信号。


例如：
	
	trap signal_handler 0

通过trap命令将signal_handler函数与信号0绑定。信号0是一个特殊的信号，在POSIX标准中，把0定义为空信号，当进程退出时会触发该信号。
